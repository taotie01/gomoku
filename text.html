<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>五子棋游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
      rel="stylesheet"
    />
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#3B82F6",
              secondary: "#10B981",
              accent: "#6366F1",
              dark: "#1F2937",
              light: "#F3F4F6",
              board: "#E2B16A",
            },
            fontFamily: {
              inter: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <style type="text/tailwindcss">
      @layer utilities {
        .content-auto {
          content-visibility: auto;
        }
        .modal-shadow {
          box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        .btn-hover {
          @apply transition-all duration-300 transform hover:scale-105 hover:shadow-lg;
        }
        .bg-board {
          background-color: #e2b16a;
          background-image: linear-gradient(
              rgba(255, 255, 255, 0.3) 1px,
              transparent 1px
            ),
            linear-gradient(
              90deg,
              rgba(255, 255, 255, 0.3) 1px,
              transparent 1px
            );
        }
        .piece-black {
          background: radial-gradient(circle at 35% 35%, #555, #000);
        }
        .piece-white {
          background: radial-gradient(circle at 35% 35%, #fff, #ddd);
        }
        .grid-pattern {
          background-size: 20px 20px;
        }
      }
    </style>
  </head>
  <body class="font-inter bg-gray-50 min-h-screen flex flex-col">
    <!-- 导航栏 -->
    <header
      class="bg-white shadow-md sticky top-0 z-50 transition-all duration-300"
    >
      <div
        class="container mx-auto px-4 py-4 flex justify-between items-center"
      >
        <div class="flex items-center space-x-2">
          <i class="fa fa-chess-board text-primary text-2xl"></i>
          <h1 class="text-xl font-bold text-dark">五子棋游戏</h1>
        </div>
        <nav>
          <ul class="flex space-x-6">
            <li>
              <a
                href="#"
                class="text-gray-600 hover:text-primary transition-colors"
                >首页</a
              >
            </li>
            <li>
              <a
                href="#"
                class="text-gray-600 hover:text-primary transition-colors"
                >游戏</a
              >
            </li>
            <li>
              <a
                href="#"
                class="text-gray-600 hover:text-primary transition-colors"
                >规则</a
              >
            </li>
          </ul>
        </nav>
      </div>
    </header>

    <!-- 主要内容区 -->
    <main class="flex-grow container mx-auto px-4 py-8">
      <div class="max-w-6xl mx-auto">
        <div class="flex flex-col md:flex-row gap-8">
          <!-- 游戏区域 -->
          <div class="flex-1 flex flex-col items-center">
            <div class="w-full max-w-2xl mb-4">
              <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-dark">五子棋</h2>
                <div id="status" class="text-lg font-medium text-gray-700">
                  当前玩家：黑棋
                </div>
              </div>

              <!-- 游戏控制区 -->
              <div class="flex flex-wrap gap-3 mb-6">
                <button
                  id="resetBtn"
                  class="bg-primary text-white font-medium py-2 px-4 rounded-lg btn-hover focus:outline-none focus:ring-2 focus:ring-primary/50"
                >
                  <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
                <button
                  id="undoBtn"
                  class="bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg btn-hover focus:outline-none focus:ring-2 focus:ring-gray-300"
                >
                  <i class="fa fa-undo mr-2"></i>悔棋
                </button>
                <button
                  id="changeSizeBtn"
                  class="bg-secondary text-white font-medium py-2 px-4 rounded-lg btn-hover focus:outline-none focus:ring-2 focus:ring-secondary/50"
                >
                  <i class="fa fa-th mr-2"></i>棋盘尺
                </button>
                <button
                  id="toggleAIBtn"
                  class="bg-accent text-white font-medium py-2 px-4 rounded-lg btn-hover focus:outline-none focus:ring-2 focus:ring-accent/50"
                >
                  <i class="fa fa-user mr-2"></i>双人模式
                </button>
              </div>

              <!-- 棋盘容器 -->
              <div
                class="relative bg-board rounded-lg shadow-xl overflow-hidden transition-all duration-500"
              >
                <canvas id="chessboard" class="w-full h-full"></canvas>
              </div>
            </div>
          </div>

          <!-- 游戏信息区 -->
          <div class="w-full md:w-80 flex flex-col">
            <div class="bg-white rounded-xl shadow-md p-6 mb-6">
              <h3 class="text-xl font-bold text-dark mb-4 flex items-center">
                <i class="fa fa-info-circle text-primary mr-2"></i>游戏信息
              </h3>
              <div class="space-y-3">
                <div class="flex justify-between items-center">
                  <span class="text-gray-600">当前模式：</span>
                  <span id="mode" class="font-medium text-dark">双人模式</span>
                </div>
                <div class="flex justify-between items-center">
                  <span class="text-gray-600">棋盘大小：</span>
                  <span id="boardSize" class="font-medium text-dark"
                    >19 x 19</span
                  >
                </div>
                <div class="flex justify-between items-center">
                  <span class="text-gray-600">总步数：</span>
                  <span id="moveCount" class="font-medium text-dark">0</span>
                </div>
              </div>
            </div>

            <!-- 游戏规则 -->
            <div class="bg-white rounded-xl shadow-md p-6">
              <h3 class="text-xl font-bold text-dark mb-4 flex items-center">
                <i class="fa fa-book text-primary mr-2"></i>游戏规则
              </h3>
              <ul class="space-y-2 text-gray-600">
                <li class="flex items-start">
                  <i class="fa fa-check-circle text-secondary mt-1 mr-2"></i>
                  <span>黑白双方轮流在棋盘上落子</span>
                </li>
                <li class="flex items-start">
                  <i class="fa fa-check-circle text-secondary mt-1 mr-2"></i>
                  <span>先在一条直线（横、竖或斜线）上形成五连子者获胜</span>
                </li>
                <li class="flex items-start">
                  <i class="fa fa-check-circle text-secondary mt-1 mr-2"></i>
                  <span>点击棋盘交叉点落子</span>
                </li>
                <li class="flex items-start">
                  <i class="fa fa-check-circle text-secondary mt-1 mr-2"></i>
                  <span>支持悔棋和重新开始功能</span>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-8 mt-12">
      <div class="container mx-auto px-4">
        <div class="flex flex-col md:flex-row justify-between items-center">
          <div class="mb-4 md:mb-0">
            <div class="flex items-center space-x-2">
              <i class="fa fa-chess-board text-primary text-xl"></i>
              <span class="font-bold text-lg">五子棋游戏</span>
            </div>
            <p class="text-gray-400 mt-2">体验经典五子棋的现代玩法</p>
          </div>
          <div class="flex space-x-6">
            <a href="#" class="text-gray-400 hover:text-white transition-colors"
              ><i class="fa fa-github text-xl"></i
            ></a>
            <a href="#" class="text-gray-400 hover:text-white transition-colors"
              ><i class="fa fa-twitter text-xl"></i
            ></a>
            <a href="#" class="text-gray-400 hover:text-white transition-colors"
              ><i class="fa fa-linkedin text-xl"></i
            ></a>
          </div>
        </div>
        <div
          class="border-t border-gray-700 mt-6 pt-6 text-center text-gray-400"
        >
          &copy; 2025 五子棋游戏. 保留所有权利.
        </div>
      </div>
    </footer>

    <!-- 棋盘尺寸选择模态框 -->
    <div
      id="sizeModal"
      class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-300"
    >
      <div
        class="bg-white rounded-2xl w-full max-w-md modal-shadow transform scale-95 transition-all duration-300"
      >
        <!-- 模态框头部 -->
        <div
          class="p-6 border-b border-gray-200 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold text-dark">选择棋盘尺寸</h3>
          <button
            id="closeSizeModalBtn"
            class="text-gray-500 hover:text-gray-700 transition-colors"
          >
            <i class="fa fa-times text-xl"></i>
          </button>
        </div>

        <!-- 模态框内容 -->
        <div class="p-6">
          <p class="text-gray-700 mb-6">请选择您想要的棋盘尺寸：</p>

          <!-- 尺寸选项 -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <button
              id="size8Btn"
              class="bg-gray-100 hover:bg-gray-200 p-4 rounded-lg text-center transition-colors duration-300 border-2 border-transparent hover:border-primary"
            >
              <div class="text-2xl font-bold mb-1">8×8</div>
              <div class="text-sm text-gray-500">小尺寸</div>
            </button>
            <button
              id="size12Btn"
              class="bg-gray-100 hover:bg-gray-200 p-4 rounded-lg text-center transition-colors duration-300 border-2 border-primary"
            >
              <div class="text-2xl font-bold mb-1">12×12</div>
              <div class="text-sm text-gray-500">中等尺寸</div>
            </button>
            <button
              id="size18Btn"
              class="bg-gray-100 hover:bg-gray-200 p-4 rounded-lg text-center transition-colors duration-300 border-2 border-transparent hover:border-primary"
            >
              <div class="text-2xl font-bold mb-1">18×18</div>
              <div class="text-sm text-gray-500">大尺寸</div>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- 胜利弹窗 -->
    <div
      id="winPopup"
      class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden"
    >
      <div
        class="bg-white rounded-2xl w-full max-w-md modal-shadow p-8 transform transition-all duration-300"
      >
        <div class="text-center">
          <div
            class="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6"
          >
            <i class="fa fa-trophy text-4xl text-secondary"></i>
          </div>
          <h3 class="text-2xl font-bold text-dark mb-2">游戏结束</h3>
          <p id="winMessage" class="text-xl text-gray-700 mb-6">黑棋胜利！</p>
          <button
            id="closeWinPopupBtn"
            class="bg-primary text-white font-medium py-3 px-8 rounded-lg btn-hover focus:outline-none focus:ring-2 focus:ring-primary/50"
          >
            再来一局
          </button>
        </div>
      </div>
    </div>

    <script>
      // 游戏常量和变量
      const canvas = document.getElementById("chessboard");
      const ctx = canvas.getContext("2d");
      const status = document.getElementById("status");
      let BOARD_SIZE = 19; // 默认19x19棋盘
      let GRID_SIZE; // 动态计算格子大小
      let board = [];
      let currentPlayer = 1; // 1为黑棋，2为白棋
      let gameOver = false;
      let moveHistory = []; // 记录每一步棋的历史
      const BOARD_MARGIN = 1 / 1.3; // 棋盘边距比例
      let isAIEnabled = false; // AI是否启用
      let AIDelay = 500; // AI思考延迟（毫秒）
      let clickTimer = null; // 点击计时器（用于防抖）
      const CLICK_DEBOUNCE_TIME = 300; // 防抖时间（毫秒）

      // 模态框元素
      const sizeModal = document.getElementById("sizeModal");
      const closeSizeModalBtn = document.getElementById("closeSizeModalBtn");
      const size8Btn = document.getElementById("size8Btn");
      const size12Btn = document.getElementById("size12Btn");
      const size18Btn = document.getElementById("size18Btn");
      const boardSizeElement = document.getElementById("boardSize");
      const moveCountElement = document.getElementById("moveCount");

      // 音频元素
      const audio = new Audio(
        "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"
      );
      audio.loop = true;
      audio.volume = 0.3;

      // 设置自适应尺寸
      function resizeCanvas() {
        const minDimension = Math.min(
          window.innerWidth * 0.9,
          window.innerHeight * 0.7
        );
        GRID_SIZE = Math.floor(minDimension / (BOARD_SIZE + BOARD_MARGIN * 2));
        canvas.width = GRID_SIZE * (BOARD_SIZE + BOARD_MARGIN * 2);
        canvas.height = GRID_SIZE * (BOARD_SIZE + BOARD_MARGIN * 2);
        drawBoard();
      }

      // 初始化棋盘
      function initBoard() {
        board = Array(BOARD_SIZE)
          .fill()
          .map(() => Array(BOARD_SIZE).fill(0));
        gameOver = false;
        currentPlayer = 1;
        status.textContent = "当前玩家：黑棋";
        moveHistory = []; // 清空历史记录
        hideWinPopup(); // 确保隐藏弹窗
        updateMoveCount();
        drawBoard();
      }

      // 更新状态文本
      function updateStatus() {
        if (gameOver) {
          status.textContent = `${
            currentPlayer === 1 ? "黑棋" : "白棋"
          } 胜利！`;
          showWinPopup(); // 显示胜利弹窗
        } else if (isAIEnabled && currentPlayer === 2) {
          status.textContent = "电脑思考中...";
          setTimeout(makeAIMove, AIDelay);
        } else {
          status.textContent = `当前玩家：${
            currentPlayer === 1 ? "黑棋" : "白棋"
          }${isAIEnabled && currentPlayer === 1 ? "（你）" : ""}`;
        }
      }

      // 更新步数计数
      function updateMoveCount() {
        moveCountElement.textContent = moveHistory.length;
      }

      // 绘制棋盘
      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制棋盘背景
        ctx.fillStyle = "#E2B16A";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 绘制网格线
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        for (let i = 0; i < BOARD_SIZE + 1; i++) {
          // 竖线
          ctx.beginPath();
          ctx.moveTo(
            GRID_SIZE * BOARD_MARGIN + i * GRID_SIZE,
            GRID_SIZE * BOARD_MARGIN
          );
          ctx.lineTo(
            GRID_SIZE * BOARD_MARGIN + i * GRID_SIZE,
            canvas.height - GRID_SIZE * BOARD_MARGIN
          );
          ctx.stroke();

          // 横线
          ctx.beginPath();
          ctx.moveTo(
            GRID_SIZE * BOARD_MARGIN,
            GRID_SIZE * BOARD_MARGIN + i * GRID_SIZE
          );
          ctx.lineTo(
            canvas.width - GRID_SIZE * BOARD_MARGIN,
            GRID_SIZE * BOARD_MARGIN + i * GRID_SIZE
          );
          ctx.stroke();
        }

        // 绘制中心点和角点
        const points = getBoardPoints();
        ctx.fillStyle = "#333";
        points.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(
            GRID_SIZE * BOARD_MARGIN + y * GRID_SIZE,
            GRID_SIZE * BOARD_MARGIN + x * GRID_SIZE,
            3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        });

        // 绘制棋子
        for (let i = 0; i < BOARD_SIZE; i++) {
          for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 1) {
              drawPiece(i, j, "#000000"); // 黑棋
            } else if (board[i][j] === 2) {
              drawPiece(i, j, "#ffffff"); // 白棋
            }
          }
        }
      }

      // 根据棋盘大小获取标记点位置
      function getBoardPoints() {
        if (BOARD_SIZE >= 15) {
          return [
            [3, 3],
            [3, BOARD_SIZE - 4],
            [BOARD_SIZE - 4, 3],
            [BOARD_SIZE - 4, BOARD_SIZE - 4],
            [Math.floor(BOARD_SIZE / 2), Math.floor(BOARD_SIZE / 2)],
          ];
        } else if (BOARD_SIZE >= 9) {
          return [[Math.floor(BOARD_SIZE / 2), Math.floor(BOARD_SIZE / 2)]];
        } else {
          return [];
        }
      }

      // 绘制棋子
      function drawPiece(x, y, color) {
        const centerX = GRID_SIZE * BOARD_MARGIN + y * GRID_SIZE;
        const centerY = GRID_SIZE * BOARD_MARGIN + x * GRID_SIZE;

        // 绘制棋子主体
        ctx.beginPath();
        ctx.arc(centerX, centerY, GRID_SIZE / 2 - 2, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        // 添加高光效果
        if (color === "#000000") {
          // 黑棋高光
          const gradient = ctx.createRadialGradient(
            centerX - GRID_SIZE / 5,
            centerY - GRID_SIZE / 5,
            0,
            centerX,
            centerY,
            GRID_SIZE / 2 - 2
          );
          gradient.addColorStop(0, "rgba(255, 255, 255, 0.3)");
          gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
          ctx.fillStyle = gradient;
          ctx.fill();
        } else {
          // 白棋阴影
          const gradient = ctx.createRadialGradient(
            centerX - GRID_SIZE / 5,
            centerY - GRID_SIZE / 5,
            0,
            centerX,
            centerY,
            GRID_SIZE / 2 - 2
          );
          gradient.addColorStop(0, "rgba(255, 255, 255, 0)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0.1)");
          ctx.fillStyle = gradient;
          ctx.fill();

          // 白棋边框
          ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }

      // 计算鼠标/触摸点对应的棋盘位置
      function getBoardPosition(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) / GRID_SIZE;
        const y = (clientY - rect.top) / GRID_SIZE;

        // 找到最近的交叉点
        const gridX = Math.round(x - BOARD_MARGIN);
        const gridY = Math.round(y - BOARD_MARGIN);

        // 计算距离，判断是否在有效范围内
        const distance = Math.sqrt(
          Math.pow(x - (gridX + BOARD_MARGIN), 2) +
            Math.pow(y - (gridY + BOARD_MARGIN), 2)
        );

        // 如果距离太远，返回null
        if (distance > 0.5) {
          return null;
        }

        // 检查是否在棋盘范围内
        if (
          gridX >= 0 &&
          gridX < BOARD_SIZE &&
          gridY >= 0 &&
          gridY < BOARD_SIZE
        ) {
          return { x: gridY, y: gridX }; // 注意：返回的是棋盘数组索引
        }

        return null;
      }

      // 检查胜利
      function checkWin(x, y) {
        const directions = [
          [1, 0],
          [0, 1],
          [1, 1],
          [1, -1],
        ];
        const player = board[x][y];

        for (let [dx, dy] of directions) {
          let count = 1;
          // 正向检查
          for (let i = 1; i < 5; i++) {
            const newX = x + dx * i;
            const newY = y + dy * i;
            if (
              newX >= 0 &&
              newX < BOARD_SIZE &&
              newY >= 0 &&
              newY < BOARD_SIZE &&
              board[newX][newY] === player
            ) {
              count++;
            } else break;
          }
          // 反向检查
          for (let i = 1; i < 5; i++) {
            const newX = x - dx * i;
            const newY = y - dy * i;
            if (
              newX >= 0 &&
              newX < BOARD_SIZE &&
              newY >= 0 &&
              newY < BOARD_SIZE &&
              board[newX][newY] === player
            ) {
              count++;
            } else break;
          }
          if (count >= 5) {
            return true;
          }
        }
        return false;
      }

      // 简单AI算法 - 评估棋盘位置价值
      function evaluatePosition(x, y, player) {
        if (board[x][y] !== 0) return -1; // 已有棋子

        const directions = [
          [1, 0],
          [0, 1],
          [1, 1],
          [1, -1],
        ];
        let maxScore = 0;

        for (let [dx, dy] of directions) {
          let score = 0;
          let consecutive = 0;
          let blockedEnds = 0;

          // 正向检查
          for (let i = 1; i < 5; i++) {
            const newX = x + dx * i;
            const newY = y + dy * i;

            if (
              newX >= 0 &&
              newX < BOARD_SIZE &&
              newY >= 0 &&
              newY < BOARD_SIZE
            ) {
              if (board[newX][newY] === player) {
                consecutive++;
              } else if (board[newX][newY] !== 0) {
                blockedEnds++;
                break;
              } else {
                break;
              }
            } else {
              blockedEnds++;
              break;
            }
          }

          // 反向检查
          for (let i = 1; i < 5; i++) {
            const newX = x - dx * i;
            const newY = y - dy * i;

            if (
              newX >= 0 &&
              newX < BOARD_SIZE &&
              newY >= 0 &&
              newY < BOARD_SIZE
            ) {
              if (board[newX][newY] === player) {
                consecutive++;
              } else if (board[newX][newY] !== 0) {
                blockedEnds++;
                break;
              } else {
                break;
              }
            } else {
              blockedEnds++;
              break;
            }
          }

          // 计算这一方向的分数
          if (consecutive === 4) {
            score = 10000; // 能连成5子
          } else if (consecutive === 3 && blockedEnds === 0) {
            score = 1000; // 活4
          } else if (consecutive === 3 && blockedEnds === 1) {
            score = 100; // 冲4
          } else if (consecutive === 2 && blockedEnds === 0) {
            score = 50; // 活3
          } else if (consecutive === 2 && blockedEnds === 1) {
            score = 10; // 冲3
          } else if (consecutive === 1 && blockedEnds === 0) {
            score = 5; // 活2
          }

          if (score > maxScore) {
            maxScore = score;
          }
        }
        return maxScore;
      }

      // AI落子
      function makeAIMove() {
        if (gameOver || currentPlayer !== 2 || !isAIEnabled) return;

        let bestScore = -1;
        let bestMoves = [];

        // 检查每个可能的位置
        for (let i = 0; i < BOARD_SIZE; i++) {
          for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] !== 0) continue;

            // 评估AI自己落子的价值
            const aiScore = evaluatePosition(i, j, 2);

            // 评估玩家落子的价值
            const playerScore = evaluatePosition(i, j, 1);

            // AI更关注自己的进攻，但也会防守
            const score = aiScore * 1.2 + playerScore;

            if (score > bestScore) {
              bestScore = score;
              bestMoves = [[i, j]];
            } else if (score === bestScore) {
              bestMoves.push([i, j]);
            }
          }
        }

        // 从最佳位置中随机选择一个
        if (bestMoves.length > 0) {
          const randomIndex = Math.floor(Math.random() * bestMoves.length);
          const [x, y] = bestMoves[randomIndex];

          // 记录这一步棋
          moveHistory.push({ x, y, player: currentPlayer });
          updateMoveCount();

          // 落子
          board[x][y] = currentPlayer;
          drawBoard();

          if (checkWin(x, y)) {
            gameOver = true;
          } else {
            currentPlayer = 1;
          }

          updateStatus();
        }
      }

      // 悔棋功能
      function undoMove() {
        if (moveHistory.length === 0 || gameOver) return;

        // 获取最后一步棋
        const lastMove = moveHistory.pop();
        const { x, y, player } = lastMove;

        // 清除棋盘上的棋子
        board[x][y] = 0;

        // 切换回上一个玩家
        currentPlayer = player;

        // 更新状态和步数
        updateStatus();
        updateMoveCount();

        // 重绘棋盘
        drawBoard();
      }

      // 切换AI对战模式
      function toggleAIMode() {
        isAIEnabled = !isAIEnabled;
        document.getElementById("toggleAIBtn").innerHTML = isAIEnabled
          ? '<i class="fa fa-robot mr-2"></i>单人模式'
          : '<i class="fa fa-user mr-2"></i>双人模式';
        document.getElementById("mode").textContent = isAIEnabled
          ? "单人模式"
          : "双人模式";

        if (isAIEnabled && currentPlayer === 2 && !gameOver) {
          updateStatus(); // 触发AI思考
        }
      }

      // 显示胜利弹窗
      function showWinPopup() {
        const popup = document.getElementById("winPopup");
        const message = document.getElementById("winMessage");

        if (popup && message) {
          message.textContent = `${
            currentPlayer === 1 ? "黑棋" : "白棋"
          }胜利！`;
          popup.style.display = "flex";

          // 添加动画效果
          setTimeout(() => {
            popup.querySelector("div").classList.add("scale-100");
            popup.querySelector("div").classList.remove("scale-95");
          }, 10);
        }
      }

      // 隐藏胜利弹窗
      function hideWinPopup() {
        const popup = document.getElementById("winPopup");
        if (popup) {
          popup.style.display = "none";
        }
      }

      // 打开棋盘尺寸选择模态框
      function openSizeModal() {
        sizeModal.classList.remove("opacity-0", "pointer-events-none");
        sizeModal.querySelector(".bg-white").classList.remove("scale-95");
        sizeModal.querySelector(".bg-white").classList.add("scale-100");

        // 重置按钮状态
        resetSizeButtons();

        // 高亮当前选择的尺寸
        highlightCurrentSize();
      }

      // 关闭棋盘尺寸选择模态框
      function closeSizeModal() {
        sizeModal.classList.add("opacity-0", "pointer-events-none");
        sizeModal.querySelector(".bg-white").classList.remove("scale-100");
        sizeModal.querySelector(".bg-white").classList.add("scale-95");
      }

      // 重置尺寸按钮状态
      function resetSizeButtons() {
        size8Btn.classList.remove("border-primary", "bg-primary/10");
        size12Btn.classList.remove("border-primary", "bg-primary/10");
        size18Btn.classList.remove("border-primary", "bg-primary/10");
      }

      // 高亮当前选择的尺寸
      function highlightCurrentSize() {
        if (BOARD_SIZE === 8) {
          size8Btn.classList.add("border-primary", "bg-primary/10");
        } else if (BOARD_SIZE === 12) {
          size12Btn.classList.add("border-primary", "bg-primary/10");
        } else if (BOARD_SIZE === 18) {
          size18Btn.classList.add("border-primary", "bg-primary/10");
        }
      }

      // 设置棋盘尺寸
      function setBoardSize(size) {
        if (BOARD_SIZE !== size) {
          BOARD_SIZE = size;
          boardSizeElement.textContent = `${BOARD_SIZE} x ${BOARD_SIZE}`;
          resizeCanvas();
          initBoard();
        }
        closeSizeModal();
      }

      // 处理点击事件
      function handleCanvasClick(clientX, clientY) {
        if (gameOver || (isAIEnabled && currentPlayer === 2)) return;
        const gridPos = getBoardPosition(clientX, clientY);

        // 防止重复点击
        if (clickTimer) {
          clearTimeout(clickTimer);
        }

        clickTimer = setTimeout(() => {
          clickTimer = null;
          if (!gridPos) return;

          // 检查位置是否已被占用
          if (board[gridPos.x][gridPos.y] === 0) {
            // 记录这一步棋
            moveHistory.push({
              x: gridPos.x,
              y: gridPos.y,
              player: currentPlayer,
            });
            updateMoveCount();

            // 落子
            board[gridPos.x][gridPos.y] = currentPlayer;
            drawBoard();

            // 添加落子音效
            const audio = new Audio(
              "data:audio/wav;base64,UklGRqQCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA"
            );
            audio.play();

            if (checkWin(gridPos.x, gridPos.y)) {
              gameOver = true;
            } else {
              currentPlayer = currentPlayer === 1 ? 2 : 1;
            }
            updateStatus();
          }
        }, CLICK_DEBOUNCE_TIME);
      }

      // 重置游戏
      function resetGame() {
        initBoard();
      }

      // 初始化背景音乐
      function initMusic() {
        // 由于浏览器自动播放策略，音乐将在用户第一次交互后播放
        document.addEventListener("click", function startMusic() {
          audio.play().catch((e) => console.log("自动播放失败:", e));
          document.removeEventListener("click", startMusic);
        });
      }

      // 初始化事件监听
      function initEventListeners() {
        // 棋盘点击事件
        canvas.addEventListener("click", (e) => {
          handleCanvasClick(e.clientX, e.clientY);
        });

        // 棋盘触摸事件
        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          if (e.touches.length === 0 && e.changedTouches.length > 0) {
            const touch = e.changedTouches[0];
            handleCanvasClick(touch.clientX, touch.clientY);
          }
        });

        // 重置按钮
        document
          .getElementById("resetBtn")
          .addEventListener("click", resetGame);

        // 悔棋按钮
        document.getElementById("undoBtn").addEventListener("click", undoMove);

        // 棋盘尺寸按钮
        document
          .getElementById("changeSizeBtn")
          .addEventListener("click", openSizeModal);

        // 关闭尺寸模态框按钮
        closeSizeModalBtn.addEventListener("click", closeSizeModal);

        // 尺寸选择按钮
        size8Btn.addEventListener("click", () => setBoardSize(8));
        size12Btn.addEventListener("click", () => setBoardSize(12));
        size18Btn.addEventListener("click", () => setBoardSize(18));

        // 点击模态框外部关闭
        sizeModal.addEventListener("click", (e) => {
          if (e.target === sizeModal) {
            closeSizeModal();
          }
        });

        // 关闭胜利弹窗按钮
        document
          .getElementById("closeWinPopupBtn")
          .addEventListener("click", () => {
            hideWinPopup();
            resetGame();
          });

        // AI模式切换按钮
        document
          .getElementById("toggleAIBtn")
          .addEventListener("click", toggleAIMode);

        // 窗口大小变化事件
        window.addEventListener("resize", resizeCanvas);
      }

      // 初始化游戏
      function initGame() {
        initMusic();
        initEventListeners();
        initBoard();
        resizeCanvas();
      }

      // 启动游戏
      initGame();
    </script>
  </body>
</html>
